## 📖HTTP란?
> HyperText Transfer Protocol의 약자로 WWW(World-Wide-Web)에 내재된 프로토콜이다.
- 인터넷상에서 데이터를 주고 받기 위한 서버/클라이언트 모델을 따르는 전송 프로토콜이자 애플리케이션 레벨의 프로토콜로 TCP/IP위에서 작동
- WWW에서 하이퍼텍스트(hypertext) 문서를 교환하기 위하여 사용되는 통신 규약.
- 인터넷 상에서 클라이언트와 서버가 자원을 주고 받을 때 쓰는 통신 규약
- HTTP는 텍스트 교환이므로, 누군가 네트워크에서 신호를 가로채면 내용이 노출되는 보안 이슈가 존재한다.

	* 클라이언트에서 요청(request)를 보내면 서버는 요청을 처리해서 응답(response)한다.
	* 암호화가 되지 않은 평문 데이터를 전송하는 프로토콜로, 제 3자가 중요한 정보를 조회할 수 있다.
	* 통신 상태를 확인하지 않으므로 위장이 가능하며, 완전성을 증명할 수 없어 변조까지 가능
- 상태를 가지고 있지 않는 Stateless 프로토콜
	* Method, Path, Version, Headers, Body 등으로 구성
- 기본적으로 80번 포트를 사용

### 비상태 연결(Sateless, Connectionless)
> 서버에 연결하고 요청해서 응답을 받으면 연결을 끊는다.

- 장점
	* 접속 유지 최소화
	* 불특정 다수를 대상으로 하는 서비스에 유리
- 단점
	* 연결을 끊어버리므로 클라이언트의 이전 상태를 알 수 없음
	* 따라서 로그인을 해도 정보 유지 불가
	* 이를 해결하기 위해 쿠키, 세션 등을 이용

## 📖HTTP 메시지란?
> HTTP 애플리케이션 간에 주고 받은 데이터의 블록들

- 데이터 블록은 메세지의 내용과 의미를 설명하는 텍스트 메타 정보로 시작한다.
- 클라이언트로부터의 요청이나 서버로부터의 응답 중 하나를 포함하며 **시작줄, 헤더 블록, 본문**의 세 항목으로 나누어진다.

1. 시작줄
	- 요청 시 : HTTP 메서드 / URL, 또는 프로토콜, 포트 도메인의 절대 경로 / HTTP 버전
	- 응답 시 : 프로토콜 버전 / 상태코드 / 상태코드 정의
2. 헤더블록 : `key:value` 로 이루어지며, 확장 가능
	- 요청 시
		```
		Accept : 클라이언트가 받을 수 있는 컨텐츠
		Cookie : 쿠키
		Content-Type : 메세지 바디 종류
		Content-Length : 메세지 바디 길이
		If-Modified-Since : 특정 날짜 이후 변경됐을 때
		```
	- 응답 시
		```
		Content-Type : 바디 데이터의 타입
		Content-Length : 바디 데이터의 크기
		Set-Cookie : 쿠키 설정
		ETag : 엔티티 태그
		```
3. 본문
	- 요청 시 : `Entity body`, 보통 공백
	- 응답 시 : HTML, JSON, Octet Stream 등


### HTTP 메서드의 종류
| 메소드 명  |  역할  | 설명  | 본문 유무 |
|--------------|-------|--------|-----|
| `GET` | 리소스 취득 | 서버에서 특정 문서를 가져옵니다. | X  |
| `HEAD` | 메세지 헤더 취득 | 서버에서 특정 문서에 대한 헤더만 가져옵니다. | X |
| `POST` | 엔티티 바디 전송 | 서버가 처리할 데이터를 전송합니다. | O |
| `TRACE` | 경로 조사 | 보낸 메세지를 다시 돌려 받습니다. | O |
| `OPTIONS` | 서포트 메소드 문의 | 요청한 URL에 어떠한 메소드 요청이 가능한지 묻습니다. | X |
| `DELETE` | 리소스 삭제 | URL의 리소스를 삭제합니다. | X |

### HTTP 상태 코드의 종류
> 상태 코드는 크게 5가지로 구분

상태코드는 클라이언트가 트랜잭션을 이해할 수 있게 하는 수단입니다. 봉 응답 메세지에 상태 코드와 사유를 기입하여 보내지만, 사유를 어떻게 작성하느냐에 대한 가이드는 존재하지 않습니다.

### 🛠 200-299 : 성공
> 클라이언트의 요청이 성공했는지에 대응하는 코드

| 상태 코드 | 사유 구절 | 의미 |
| ------- | ------- | -------- |
| 200 | OK | 요청이 정상이며 엔티티 본문이 요청된 리소스를 포함하고 있다는 의미 |
| 202 | Accepted | 요청은 허용되었으나 서버는 어떤 동작도 수행하지 않았음을 의미 |

### 🛠300-399 : 리다이렉션 
> 클라이언트가 관심있는 리소스에 대해 다른 위치를 사용하라고 응답

만약 리소스가 이동되었다면 클라이언트에게 해당 정보, 또는 선택적으로 location 헤더를 전송할 수 있으며 브라우저는 사용자를 귀찮게 하지 않고 새 위치로 이동
| 상태 코드 | 사유 구절 | 의미 |
| ------- | ------- | -------- |
| 300 | Multiple Choices | 클라이언트가 여러 리소스를 가리키는 URL을 요청했다면 그 리소스의 목록과 함께 반환 | 
} 301 | Accepted | 요청한 URL이 이동되었을 떄 사용하며, Location 헤더에 URL을 포함해야 한다. |

### 🛠400-499 : 클라이언트
> 많은 클라이언트 에러는 브라우저에 의해 처리된다.

| 상태 코드 | 사유 구절 | 의미 |
| ------- | ------- | -------- |
| 401 | Unauthorized | 클라이언트의 인증(유효한 사용자 ID와 암호)를 요규 |
| 403 | Forbidden | 요청이 서버에 의해 거부되었음을 의미 | 
| 404 | Not Found | 서버가 요청한 URL을 찾을 수 없음을 알려주기 위해 사용 |

### 🛠500-599 : 서버 에러
> 프록시는 클라이언트의 입장으로 서버와 통신하는데, 이때 발생하는 문제를 500번대 상태 코드로 알린다.

클라이언트는 올바른 요청을 전송했음에도 서버 자체에서 에러가 발생하는 경우.

| 상태 코드 | 사유 구절 | 의미 |
| ------- | ------- | -------- |
| 500 | Internal Server Error | 서버가 요청을 처리하지 못하게 만드는 에러가 발생했음을 의미 |
| 502 | Bad Gateway | 요청-응답 연쇄의 다음 링크로부터 에러가 발생했음을 의미 | 
| 503 | Service Unavailable | 현재는 서버가 요청을 처리할 수 없으나 나중에는 가능함을 의미

## 📖서버로 요청하면 일어나는 일련의 과정
> 브라우저에 URL을 입력했을 떄 수행되는 과정

1. 브라우저에 URL 입력
2. 호스트 명 획득
3. DNS 서버에 IP주소 요청
4. 포트(port) 번호 획득
5. IP주소로 포트 번호에 연결(Connection)
	=> 여기에서 `3-way hand-shaking` 이 일어난다.
6. 클라이언트가 HTTP 메서드를 통하여 서버에 요청
7. 서버가 HTTP 상태 코드로 클라이언트에 응답
8. 커낵션 종료

아래는 자세한 버전

1. 기본 정보를 확인
	* 브라우저의 로컬 `hosts` 파일에 입력한 URL에 연결된 정보가 있는지 확인
2. 외부와 통신할 준비
	* `DHCP(Dynamic Host Configuration Protocol)` 에서 브라우저의 IP주소, 가장 가까운 라우터(Router)의 IP 주소, 가장 가까운 DNS 서버의 IP 주소를 수신 
	* `주소 결정 프로토콜(Address Resolution Protocol, ARP)` 로 이동하려는 URL 호스트에 연결된 IP 주소와 가장 가까운 라우터의 MAC 주소를 확인
3. DNS 서버와 IP 주소를 송수신
	* DNS Query를 DNS 서버에 소잇낳면 DNS 서버는 웹 서버의 IP 주소를 브라우저로 반환
4. 웹 서버에 접속(연결)
	* 요청을 위해 TCP 소켓을 개방한 뒤 연결(Connection)
	* 이 과정에서 3-way hand-shaking이 일어나며, TCP 연결이 성공되면 요청이 소켓을 통해 전송된다.
5. 서버는 요청을 처리해 클라이언트에게 응답하며, 커넥션을 종료
6. 응답된 전송을 브라우저가 수신

## 📖 HTTP와 HTTPS

### HTTP의 보안 취약점
> HTTP란 인터넷 상에서 데이터를 주고 받기 위한 서버/클라이언트 모델을 따르는 전송 프로토콜이자 애플리케이션 레벨의 프로토콜로 TCP/IP 위에서 동작한다.
> 
1. 도청이 가능하다
	* 평문으로 통신하기 때문에 도청이 가능하다.
	* 이를 해결하기 위해 통신 자체를 암호화(HTTPS)하거나 데이터를 암호화 하는 방법 등이 있다.
	* 데이터를 암호화 하는 경우 수신 측에서는 보호화 과정이 필요하다.

2. 위장이 가능하다
	* 통신 상태를 확인하지 않기 때문에 위장된 상태와 통신할 수 있다.
	* HTTPS는 CA 인증서를 통해 인증된 상태와 통신이 가능하다.

3. 변조가 가능하다.
	* 완전성을 보장하지 않기 때문에 변조가 가능하다.
	* HTTPS는 메세지 인증 코드(MAC), 전자 서명 등을 통해 변조를 방지한다.

### HTTPS란?
- 인터넷 상테서 정보를 암호화하는 SSL 프로토콜을 사용하는 클라이언트와 서버가 자원을 주고 받을 때 쓰는 통신 규약
- HTTPS는 텍스트를 암호화한다.(공개키 암호화 방식으로)

### HTTPS 통신 흐름
1. 애플리케이션 서버(A)를 만드는 기업은 HTTPS를 적용하기 위해 공개키와 개인키를 만든다.
2. 신뢰할 수 있는 CA 기업을 선택하고, 그 기업에게 자신의 공개키 관리를 부탁하며 계약을 한다.
	* CA란?  : Certificate Authority로 공개키를 저장해주는 신뢰성이 검증된 민간기업
3. 계약 완료된 CA 기업은 해당 기업의 이름, A서버 공개키, 공개키 암호화 방법을 담은 인증서를 만들고,
	해당 인증서를 CA 기업의 개인키로 암호화해서 A서버에게 제공한다.
4. A 서버는 암호화된 인증서를 갖게 되었다. 이제 A서버는 A서버의 공개키로 암호화된 HTTPS 요청이 아닌 요청이 오면, 이 암호화된 인증서를 클라이언트에게 건내준다.
5. 클라이언트가 main.html 파일을 달라고 A서버에 요청했다고 가정하자. HTTPS 요청이 아니기 때문에 CA기업이 A서버의 정보를 CA기업의 개인키로 암호화한 인증서를 받게 된다.
	* CA 기업의 공개키는 브라우저가 이미 알고 있다.(세계적으로 신뢰할 수 있는 기업으로 등록되어 있기 때문에, 브라우저가 인증서를 탐색하여 해독이 가능)
6. 브라우저는 해동한 뒤 A서버의 공개키를 얻게 된다.
7. 클라이언트가 A서버와 HandShaking 과정에서 주고받은 난수를 조합하여 pre-master-secret-key를 생성한 뒤, A서버의 공개키로 해당 대칭키를 암호화하여 서버로 보낸다.
8. A서버는 암호화된 대칭키를 자신의개인키로 복호화하여 클라이언트와 동일한 대칭키를 획득한다.
9. 클라이언트, 서버는 각각 pre-master-secret-key를 master-secret-key로 만든다.
10. master-secret-key를 통해 session-key를 생성하고 이를 이용하여 대칭키 방식으로 통신한다.
11. 각 통신이 종료될 때마다 session-key를 파기한다.

HTTPS도 무조건 안전한 것은 아니다.(신뢰받는 CA 기업이 아닌 자체 인증서를 발급한 경우 등)
이떄는 HTTPS지만 브라우저에거 `주의 요함`, `안전하지 않은 사이트`와 같은 알림으로 주의 받게 된다. 

